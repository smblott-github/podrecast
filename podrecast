#!/usr/bin/env python

# ###########################################################################
# Imports...

import os, sys, urllib2
from urlparse import urlparse, urlunparse
from tempfile import mkstemp
from fcntl import flock, LOCK_EX, LOCK_NB
from subprocess import call
from optparse import OptionParser
from copy import copy

# ###########################################################################
# Command-line arguments...

help_text ='''
Normally, podrecast downloads new podcast files in acordance with its
configuration and arguments.  However, if the following four CGI environment
variables are all defined, then it behaves instead as a CGI script:
REQUEST_METHOD, HTTP_HOST, SCRIPT_NAME and PATH_INFO.
'''

parser = OptionParser(epilog=help_text[1:])
parser.add_option("-m", "--max",         type=int, dest="max",     default=0, help="the maximum number of podcasts to download from each feed (default: 0, meaning download all new podcasts)")
parser.add_option("-c", "--catchup",     action="store_true", dest="catchup",     default=False, help="mark all podcasts as read")
parser.add_option("-a", "--autocatchup", action="store_true", dest="autocatchup", default=False, help="mark all podcasts in newly-encountered feeds as read; a feed is \"newly-encountered\" if either its directory or its feed file does not initially exist")
parser.add_option("-r", "--roots",       action="store_true", dest="roots",       default=False, help="output only a list of configured root directories")

(options, args) = parser.parse_args()

# ###########################################################################
# Globals and "constants", ...

errors = 0
lock = None
cgi = "PATH_INFO" in os.environ and "SCRIPT_NAME" in os.environ and "HTTP_HOST" in os.environ and "REQUEST_METHOD" in os.environ

## How should we handle the case where only some of these are set?
## if not cgi and ("PATH_INFO" in os.environ or "SCRIPT_NAME" in os.environ or "HTTP_HOST" in os.environ or "REQUEST_METHOD" in os.environ):
##    sys.stderr.write("error: insufficient environment variables for CGI\n")
##    sys.exit(1)

def done_file(fname):
   return "." + fname + ".podrecast_done"

def download_file(fname):
   return fname + ".podrecast_download"

def feed_file():
   return ".podrecast_feed.xml"

# Configuration files.
# The first available configuration file is chosen.
#
# If using the CGI functionality of podrecast, then it makes sense to use
# "/etc/podrecast.conf" or "/usr/local/etc/podrecast.conf", because these are
# the only two which are findable by all users, including the user account
# under which the web server is running.
#

configs = [ 
            "./podrecast.conf",
            "~/.podrecast.conf",
            "/usr/local/etc/podrecast.conf",
            "/etc/podrecast.conf"
            ]

# ###########################################################################
# Utilities...

def log(*args):
   if cgi: print "X-PODRECAST-LOG:", " ".join(args)
   else:   print " ".join(args)

def elog(*args):
   if cgi: print "X-PODRECAST-ERROR:", " ".join(args)
   else:   sys.stderr.write(" ".join(args) + "\n")

def touch(fname):
   with file(fname, 'a'):
      os.utime(fname, None)

def slurp(fname):
   with open(fname) as fd:
      return fd.read()

def fd_copy(src,dst):
   sz = 4 * 4096
   while True:
      chunk = os.read(src,sz)
      if not chunk: return
      os.write(dst,chunk)

def chdir(directory):
   if os.path.exists(directory) and not os.path.isdir(directory):
      raise Exception("exists, but is not a directory: " + directory)
   if not os.path.isdir(directory):
      log("creating:", directory)
      os.makedirs(directory)
   #
   log("chdir:", directory)
   os.chdir(directory)

def wget(url,fname,options=[]):
   tmp = None
   extras = [] if sys.stdout.isatty() else [ '-q' ]
   log("wget:", url)
   try:
      fd, tmp = mkstemp(dir=".", prefix=fname, suffix=".podrecast.download.tmp")
      os.close(fd)
      status = call([ 'wget', '-O', tmp ] + options + extras + [ url ])
      # TODO:
      # Respect umask.
      os.chmod(tmp,0644)
      os.rename(tmp,fname)
      log("done:", fname)
   except:
      if tmp and os.path.exists(tmp):
         os.unlink(tmp)
      raise

# ###########################################################################
# Non-standard libraries...

try:
   from lxml import objectify, etree
except:
   elog("import error: package/module python-lxml not found")
   sys.exit(1)

# ###########################################################################
# Configuration...

def choose_config(quiet=False):
   for config in configs:
      config = os.path.expanduser(config)
      if os.path.isfile(config) and os.access(config, os.R_OK):
         if not quiet:
            log("config:", config)
         return config
   raise Exception("could failed to find config file: " + str(configs))

def read_config(config,locking=False):
   global lock
   #
   lock = fd = open(config)
   lines = fd.readlines()
   #
   if locking:
      try:
         flock(lock.fileno(), LOCK_EX | LOCK_NB)
      except: raise Exception("locking, would block: " + config)
   else:
      lock = None
      fd.close()
   #
   lines = [ line.strip() for line in lines ]
   lines = [ line for line in lines if len(line) ]
   lines = [ line for line in lines if not line.startswith("#") ]
   lines = [ line.split() for line in lines ]
   return lines

# ###########################################################################
# Handle feeds and enclosures...

def download_feeds(config,options):
   global errors
   for line in read_config(config,True):
      if line[0] == "root":
         if len(line) != 2:
            raise Exception("config: invalid root directive: " + str(line))
         root = line[1]
         if not os.path.isabs(root):
            raise Exception("config: root must be an absolute path: " + str(line))
         chdir(root)
      else:
         try:
            if len(line) != 2:
               raise Exception("config: invalid feed: " + str(line))
            directory, url = line
            download_feed(directory,url,options)
         except (KeyboardInterrupt, SystemExit):
            raise
         except Exception as error:
            elog("feed error:", directory, url, str(error))
            errors += 1

def download_feed(directory,url,options):
   global errors
   cwd = os.getcwd()
   try:
      existing_feed = os.path.isdir(directory)
      chdir(directory)
      #
      existing_feed = existing_feed and os.path.isfile(feed_file())
      if options.autocatchup and not existing_feed:
         options = copy(options)
         options.catchup = True
      #
      wget(url,feed_file(), [ '-q' ])
      feed, enclosures = slurp_enclosures(feed_file())
   except:
      chdir(cwd)
      raise
   #
   if 0 < options.max:
      handle_enclosures = enclosures[:options.max]
      catchup_enclosures = enclosures[options.max:]
   else:
      handle_enclosures = enclosures
      catchup_enclosures = []
   #
   for enclosure in handle_enclosures:
      try:
         handle_enclosure(enclosure,options)
      except (KeyboardInterrupt, SystemExit):
         raise
      except Exception as error:
         elog("enclosure error:", str(error))
         errors += 1
   #
   options = copy(options)
   options.catchup = True
   for enclosure in catchup_enclosures:
      try:
         handle_enclosure(enclosure,options)
      except (KeyboardInterrupt, SystemExit):
         raise
      except Exception as error:
         elog("enclosure error:", str(error))
         errors += 1
   #
   chdir(cwd)

def slurp_enclosures(fname):
   text = slurp(fname)
   feed = objectify.fromstring(text)
   return feed, feed.findall('.//channel/item/enclosure')

def handle_enclosure(enclosure,options):
   attributes = enclosure.attrib
   if not "url" in attributes:
      raise Eception("enclosure, no url")
   #
   url = urlparse(attributes["url"])
   fname = os.path.basename(url.path)
   #
   if os.path.exists(done_file(fname)):
      # Touch the done_file().  That way, done_file()s which are more than a
      # little older than the feed file itself no longer occur in the feed, and
      # might safely be deleted.  This must, therefore, be the first of this
      # sequence of steps.
      #
      touch(done_file(fname))
      # log("done:", fname)
      return
   #
   if os.path.exists(fname):
      log("ready:", fname)
      return
   #
   if os.path.exists(download_file(fname)):
      log("downloaded:", fname)
      return
   #
   if options.catchup:
      log("touch:", fname)
      touch(done_file(fname))
      return
   #
   # OK.  Download the file.
   wget(urlunparse(url),download_file(fname))
   touch(done_file(fname))

# ###########################################################################
# Handle cgi requests...

def handle_cgi():
   roots = [ line for line in read_config(choose_config()) if line[0] == "root" ]
   #
   if len(roots) != 1 or len(roots[0]) != 2:
      elog("error: cannot serve CGI without a single, valid root")
      sys.exit(1)
   root = roots[0][1]
   #
   # TODO:
   # os.environ['PATH_INFO'] and path are tainted!
   path = root + os.environ['PATH_INFO']
   if os.path.isdir(path) and os.access(path, os.R_OK) and os.access(path, os.X_OK):
      return handle_cgi_directory(path)
   if os.path.isfile(path) and os.access(path, os.R_OK):
      return handle_cgi_file(path)
   #
   elog("error: does not exist:", path)
   sys.exit(1)
   #

# ###########################################################################
# Handle cgi requests for feeds...

def handle_cgi_directory(path):
   chdir(path)
   #
   if not os.path.isfile(feed_file()) or not os.access(feed_file(), os.R_OK):
      elog("error: cannot read feed file:", path + "/" + feed_file())
      sys.exit(1)
   #
   feed, enclosures = slurp_enclosures(feed_file())
   for enclosure in enclosures:
      attributes = enclosure.attrib
      url = urlparse(attributes["url"])
      fname = os.path.basename(url.path)
      if not os.path.isfile(fname) or not os.access(fname, os.R_OK):
         item = enclosure.getparent()
         item.getparent().remove(item)
         continue
      # Content is ready...
      #
      http_host = os.environ['HTTP_HOST']
      script_name = os.environ['SCRIPT_NAME']
      path_info = os.environ['PATH_INFO']
      attributes["url"] = "http://" + http_host + script_name + path_info + "/" + fname
   #
   print "Content-Type: text/xml"
   print
   print etree.tostring(feed)
   sys.exit(0)

# ###########################################################################
# Handle cgi requests for files...

def handle_cgi_file(path):
   #
   # TODO:
   # Look up the MIME type and calculate the content length.
   stat = os.stat(path)
   print "Content-Type: audio/mpeg"
   print "Content-Length: ", stat.st_size
   print
   sys.stdout.flush()
   fd = os.open(path, os.O_RDONLY)
   fd_copy(fd,sys.stdout.fileno())
   sys.exit(0)

# ###########################################################################
# Root directories...

def read_roots(quiet=False):
   return [ line for line in read_config(choose_config(quiet)) if line[0] == "root" ]

def show_roots():
   for root in read_roots(True):
      if len(root) == 2:
         print root[1]
      else:
         elog("error: invalid root: " + str(root))
         sys.exit(1)

# ###########################################################################
# Main...

if __name__ == "__main__":
   #
   if options.roots:
      show_roots()
      sys.exit(0)
   #
   if cgi:
      handle_cgi()
      sys.exit(0)
   #
   download_feeds(choose_config(),options)
   if ( 0 < errors ):
      elog("errors:", str(errors))
      sys.exit(1)

