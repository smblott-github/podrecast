#!/usr/bin/env python

import os, sys
from urlparse import urlparse, urlunparse
from tempfile import mkstemp

cgi = "PATH_INFO" in os.environ

def log(*args):
   if cgi:
      print "X-REPODGET-LOG:", " ".join(args)
   else:
      print " ".join(args)

def elog(*args):
   if cgi:
      print "X-REPODGET-ERROR:", " ".join(args)
   else:
      sys.stderr.write(" ".join(args) + "\n")

try:
   from requests import get
except:
   elog("import error: python-requests not found")
   sys.exit(1)

try:
   from lxml import objectify, etree
except:
   elog("import error: python-lxml not found")
   sys.exit(1)

catchup = True
catchup = False

def fetch_url(url):
   try:
      log("get:", url)
      response = get(url)
      if response.status_code != 200:
         raise Exception()
      return response.content
   except (KeyboardInterrupt, SystemExit):
      raise
   except:
      raise Exception("failed to download: " + url)

def parse(text,url):
   try:
      return objectify.fromstring(text)
   except (KeyboardInterrupt, SystemExit):
      raise
   except Exception as error:
      raise Exception("failed to parse rss: " + url)

def fetch_feed(url):
   text = fetch_url(url)
   return parse(text,url)

def chdir(directory):
   try:
      exists = os.path.isdir(directory)
      if not exists:
         log("creating:", directory)
         os.makedirs(directory)
      log("chdir:", directory)
      os.chdir(directory)
      return not exists
   except (KeyboardInterrupt, SystemExit):
      raise
   except OSError as error: 
      if error.errno == os.errno.EEXIST and os.path.isdir(directory):
         pass
      else:
         raise Exception("failed to create/change directory: " + directory)
   except:
      raise Exception("failed to create/change directory: " + directory)

def touch(fname, times=None):
   log("touch:", fname)
   with file(fname, 'a'):
      os.utime(fname, times)

def done_file(fname):
   return "." + fname + ".done"

def catchup_file(fname):
   return done_file(fname)

def download_file(fname):
   return fname + ".repodcast_download"

def feed_file():
   return ".repodcast_feed.xml"

def http_download(url,fname):
   tmp = None
   try:
      log("download:", url)
      fd, tmp = mkstemp(dir=".", prefix=fname, suffix=".repodget.tmp")
      request = get(url, stream=True)
      for data in request.iter_content(chunk_size=4096): 
         if data:
            os.write(fd,data)
      os.close(fd)
      #
      # Would be better to respect umask, here...
      os.chmod(tmp,0644)
      os.rename(tmp,fname)
      log("done:", fname)
   except:
      if tmp and os.path.exists(tmp):
         os.unlink(tmp)
      raise

def handle_enclosue(catchup,enclosure):
   attributes = enclosure.attrib
   if not "url" in attributes:
      elog("enclosure without url!")
      return
   #
   url = urlparse(attributes["url"])
   fname = os.path.basename(url.path)
   #
   try:
      #
      if os.path.exists(catchup_file(fname)):
         # print "caught up:", fname
         return
      #
      if os.path.exists(done_file(fname)):
         # print "already done:", fname
         return
      #
      if os.path.exists(download_file(fname)):
         # print "already downloaded:", fname
         return
      #
      if os.path.exists(fname):
         # print "already exists:", fname
         return
      #
      if catchup:
         touch(catchup_file(fname))
         return
      #
      # OK.  Download the file.
      http_download(urlunparse(url),download_file(fname))
      touch(done_file(fname))
      #
   except (KeyboardInterrupt, SystemExit):
      raise
   except:
      raise Exception("failed to download: " + url)

def download_feed(catchup,directory,url,username=None,password=None):
   cwd = os.getcwd()
   errors = 0
   enclosures = None
   try:
      catchup = chdir(directory) or catchup
      feed = fetch_feed(url)
      enclosures = feed.findall('.//channel/item/enclosure')
   except (KeyboardInterrupt, SystemExit):
      raise
   except Exception as error:
      elog("error:", str(error))
      chdir(cwd)
      return 1
   #
   for enclosure in enclosures:
      try:
         handle_enclosue(catchup,enclosure)
      except (KeyboardInterrupt, SystemExit):
         raise
      except:
         elog("error:", str(error))
         errors += 1
   #
   try:
      with open(feed_file(), 'w') as fd:
         fd.write(etree.tostring(feed))
   except (KeyboardInterrupt, SystemExit):
      raise
   except:
      raise Exception("failed to write feed file: " + directory)
   #
   chdir(cwd)
   return errors

def read_config(config):
   lines = None
   #
   log("config:", config)
   try:
      with open(config) as fd:
         lines = fd.readlines()
   except:
      elog("error: failed to read", config)
      sys.exit(1)
   #
   lines = [ line.strip() for line in lines ]
   lines = [ line for line in lines if len(line) ]
   lines = [ line for line in lines if not line.startswith("#") ]
   lines = [ line.split() for line in lines ]
   return lines

def handle_config(config):
   errors = 0
   lines = read_config(config)
   #
   try:
      for line in lines:
         if line[0] == "root":
            if len(line) == 2:
               root = line[1]
               if not os.path.isabs(root):
                  raise Exception("config: root must be absolute path: " + str(line))
               chdir(root)
            else:
               raise Exception("config: invalid root: " + str(line))
         else:
            if 4 < len(line):
               raise Exception("config: invalid feed (too many tokens): " + str(line))
            #
            line.extend([None,None,None])
            line = line[:4]
            url, directory, username, password = line
            if not directory:
               raise Exception("config: invalid feed (no directory): " + str(line))
            #
            errors += download_feed(catchup,directory,url,username,password)
            #
   except Exception as error:
      elog("error:", str(error))
      sys.exit(1)
   #
   return errors

def choose_config():
   configs = [ "./repodcast.conf", "~/.repodcast.conf", "/etc/repodcast.conf" ]
   for config in configs:
      config = os.path.expanduser(config)
      if os.path.isfile(config) and os.access(config, os.R_OK):
         return config
   raise Exception("could not find config file: " + str(configs))

def main():
   errors = 0
   choose_config()
   errors += handle_config(choose_config())
   #
   if 0 < errors:
      elog("feed errors:", str(errors))
   sys.exit(0 if errors == 0 else 1)

def handle_cgi():
   lines = read_config(choose_config())
   lines = [ line for line in lines if line[0] == "root" ]
   #
   if len(lines) != 1 or len(lines[0]) != 2:
      elog("error: cannot serve CGI without a single root")
      sys.exit(1)
   #
   root = lines[0][1]
   path = os.environ['PATH_INFO']
   try:
      # TODO:
      # path is not secure!
      chdir(root + path)
   except:
      elog("error: cannot chdir:", root)
      sys.exit(1)
   pass

if __name__ == "__main__":
   if cgi:
      handle_cgi()
   else:
      main()

